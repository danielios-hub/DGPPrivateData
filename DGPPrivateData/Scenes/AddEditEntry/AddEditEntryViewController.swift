//
//  AddEditEntryViewController.swift
//  DGPPrivateData
//
//  Created by Daniel Gallego Peralta on 4/3/21.
//  Copyright (c) 2021 ___ORGANIZATIONNAME___. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

import UIKit
import DGPExtensionCore

protocol AddEditEntryDisplayLogic: AnyObject {
    func displayInitialData(viewModel: AddEditEntryScene.Load.ViewModel)
    func displayEntryCreated(viewModel: AddEditEntryScene.Save.ViewModel)
    func displaySelectedCategory(viewModel: AddEditEntryScene.UpdateCategory.ViewModel)
    func displayUpdatePassword(viewModel: AddEditEntryScene.UpdatePassword.ViewModel)
    func displayUpdateFavorite(viewModel: AddEditEntryScene.UpdateFavorite.ViewModel)
    func displayError(viewModel: ErrorViewModel)
    func displayToast(with message: String)
}

class AddEditEntryViewController: UIViewController, AddEditEntryDisplayLogic, Storyboarded {
    var interactor: AddEditEntryBusinessLogic?
    var router: (NSObjectProtocol & AddEditEntryRoutingLogic & AddEditEntryDataPassing)?
    
    enum TagTextField: Int {
        case title = 1
        case username = 2
        case password = 3
        case notes = 4
    }
    
    //MARK: - Instance properties
    
    var textPlaceholder: String = NSLocalizedString("Add anything you want to save", comment: "placeholder for the notes textView")
    var viewModel: AddEditEntryScene.Load.ViewModel?
    
    var addEntryView: AddEditEntryView! {
        guard isViewLoaded else {
            return nil
        }
        return (view as! AddEditEntryView)
    }
    
    var textView: UITextView? {
        return addEntryView?.textViewNotes
    }
    
    var isSelectingCategory = false
    
    // MARK: Object lifecycle
    
    override init(nibName nibNameOrNil: String?, bundle nibBundleOrNil: Bundle?) {
        super.init(nibName: nibNameOrNil, bundle: nibBundleOrNil)
        setup()
    }
    
    required init?(coder aDecoder: NSCoder) {
        super.init(coder: aDecoder)
        setup()
    }
    
    // MARK: Setup
    
    private func setup() {
        let viewController = self
        let interactor = AddEditEntryInteractor()
        let presenter = AddEditEntryPresenter()
        let router = AddEditEntryRouter()
        viewController.interactor = interactor
        viewController.router = router
        interactor.presenter = presenter
        presenter.viewController = viewController
        router.viewController = viewController
        router.dataStore = interactor
    }
    
    // MARK: Routing
    
    override func prepare(for segue: UIStoryboardSegue, sender: Any?) {
        if let scene = segue.identifier {
            let selector = NSSelectorFromString("routeTo\(scene)WithSegue:")
            if let router = router, router.responds(to: selector) {
                router.perform(selector, with: segue)
            }
        }
    }
    
    // MARK: View lifecycle
    
    override func viewDidLoad() {
        super.viewDidLoad()
        setupView()
        setupObservers()
        setPlaceholder()
        loadInitialData()
        loadCategory()
    }
    
    private func setupObservers() {
        let notificationCenter = NotificationCenter.default
        notificationCenter.addObserver(self, selector: #selector(adjustForKeyboard), name: UIResponder.keyboardWillChangeFrameNotification, object: nil)
        notificationCenter.addObserver(self, selector: #selector(adjustForKeyboard), name: UIResponder.keyboardWillHideNotification, object: nil)
    }
    
    private func setupView() {
        addEntryView.setup(target: self,
                           actionEdit: #selector(editPassword),
                           actionCopy: #selector(copyPassword))
        navigationItem.title = NSLocalizedString("Add an Item", comment: "title of the add entry screen")
        navigationItem.rightBarButtonItem = UIBarButtonItem(barButtonSystemItem: .done, target: self, action: #selector(saveEntry))
        addEntryView.viewTitle.textField.delegate = self
        addEntryView.viewUsername.textField.delegate = self
        addEntryView.viewPassword.textField.delegate = self
        addEntryView.textViewNotes.delegate = self
        isEnabledButton(true)
        
        let picker = DGPPickerView(frame: .zero, viewModel: self)
        addEntryView.setupCategoryTextField(with: picker)

        addEntryView.favoriteButton.addTarget(self, action: #selector(toggleIsFavorite), for: .touchUpInside)

        configureTagView()

        addObserver(addEntryView.viewTitle.textField)
        addObserver(addEntryView.viewUsername.textField)
        addObserver(addEntryView.viewPassword.textField)
    }
    
    private func configureTagView() {
        addEntryView.viewTitle.textField.tag = TagTextField.title.rawValue
        addEntryView.viewUsername.textField.tag = TagTextField.username.rawValue
        addEntryView.viewPassword.textField.tag = TagTextField.password.rawValue
        addEntryView.textViewNotes.tag = TagTextField.notes.rawValue
    }
    
    // MARK: Output
    
    func loadInitialData() {
        let request = AddEditEntryScene.Load.Request()
        interactor?.loadInitialData(request: request)
    }
    
    func loadCategory() {
        interactor?.updatedCategory(request: AddEditEntryScene.UpdateCategory.Request())
    }
    
    func loadPassword(text: String) {
        interactor?.updatePassword(request: AddEditEntryScene.UpdatePassword.Request(password: text))
    }
    
    //MARK: - Input
    
    func displayInitialData(viewModel: AddEditEntryScene.Load.ViewModel) {
        self.viewModel = viewModel
        addEntryView.updateCategory(name: viewModel.categoryText, icon: viewModel.categoryIcon)
        showEntryFields(viewModel.entry)
    }
    
    func displayEntryCreated(viewModel: AddEditEntryScene.Save.ViewModel) {
        router?.routeToListEntry()
    }
    
    func displaySelectedCategory(viewModel: AddEditEntryScene.UpdateCategory.ViewModel) {
        addEntryView.updateCategory(name: viewModel.categoryText, icon: viewModel.categoryIcon)
    }
    
    func displayUpdatePassword(viewModel: AddEditEntryScene.UpdatePassword.ViewModel) {
        addEntryView.viewPassword.textField.text = viewModel.password
    }
    
    func displayUpdateFavorite(viewModel: AddEditEntryScene.UpdateFavorite.ViewModel) {
        addEntryView.updateFavorite(selected: viewModel.isFavorite)
    }
    
    func displayError(viewModel: ErrorViewModel) {
        view.makeToast(viewModel.msg, position: .bottom)
    }
    
    func displayToast(with message: String) {
        view.makeToast(message, position: .center)
    }
    
    //MARK: - Actions
    
    @objc func saveEntry() {
        interactor?.save(request: AddEditEntryScene.Save.Request())
    }
    
    @objc func editPassword() {
        router?.routeToPasswordGenerator()
    }
    
    @objc func copyPassword() {
        let request = AddEditEntryScene.Copy.Request(text: addEntryView.viewPassword.textField.text!)
        interactor?.copyText(request: request)
    }
    
    @objc func toggleIsFavorite() {
        let request = AddEditEntryScene.UpdateFavorite.Request()
        interactor?.toggleIsFavorite(request: request)
    }
    
    @objc func adjustForKeyboard(notification: Notification) {
        guard let keyboardValue = notification.userInfo?[UIResponder.keyboardFrameEndUserInfoKey] as? NSValue else { return }
        let keyboardEndFrame = keyboardValue.cgRectValue
        let keyboardFrame = view.convert(keyboardEndFrame, from: view.window)
        
        self.addEntryView.scrollView.contentInset.bottom = notification.name == UIResponder.keyboardWillHideNotification ? .zero : keyboardFrame.height
    }
    
    //MARK: - Utils
    
    func isEnabledButton(_ enabled: Bool) {
        navigationItem.rightBarButtonItem?.isEnabled = enabled
    }
    
    func updatedText(_ text: String, tag: Int) {
        switch tag {
        case TagTextField.title.rawValue:
            interactor?.setTitle(text)
        case TagTextField.username.rawValue:
            interactor?.setUsername(text)
        case TagTextField.password.rawValue:
            interactor?.setPassword(text)
        case TagTextField.notes.rawValue:
            interactor?.setNotes(text)
        default: break
        }
    }
    
    func isValid() -> Bool {
        return self.router?.dataStore?.isValid == true
    }
    
    func showEntryFields(_ entry: Entry) {
        addEntryView.viewTitle.textField.text = entry.title
        addEntryView.viewUsername.textField.text = entry.username
        addEntryView.viewPassword.textField.text = entry.password
        addEntryView.updateFavorite(selected: entry.favorite)
        
        if !entry.notes.isEmpty {
            addEntryView.textViewNotes.text = entry.notes
            addEntryView.textViewNotes.textColor = .black
        }
        
    }
}

//MARK: - UITextField Delegate

extension AddEditEntryViewController: UITextFieldDelegate {
    
    func addObserver(_ textField: UITextField) {
        textField.addTarget(self, action: #selector(textFieldDidChange(_:)), for: .editingChanged)
        textField.autocorrectionType = .no
    }
    
    func textFieldShouldReturn(_ textField: UITextField) -> Bool {
        textField.resignFirstResponder()
        return true
    }
    
    func textFieldShouldEndEditing(_ textField: UITextField) -> Bool {
        return true
    }
    
    @objc func textFieldDidChange(_ textField: UITextField) {
        updatedText(textField.text!, tag: textField.tag)
        checkEnabledPublish()
    }
}

//MARK: - UITextView Delegate

extension AddEditEntryViewController: UITextViewDelegate, UITextViewPlaceholderProtocol {
    
    func textView(_ textView: UITextView, shouldChangeTextIn range: NSRange, replacementText text: String) -> Bool {
        let currentText:String = textView.text
        let updatedText = (currentText as NSString).replacingCharacters(in: range, with: text)

        if updatedText.isEmpty {
            setPlaceholder()
            textView.selectedTextRange = textView.textRange(from: textView.beginningOfDocument, to: textView.beginningOfDocument)
            updateViewModelText(textView: textView)
            checkEnabledPublish()
        }

         else if textView.textColor == colorPlaceholder && !text.isEmpty {
            textView.textColor = UIColor.black
            textView.text = text
            
            updateViewModelText(textView: textView)
            checkEnabledPublish()
        } else {
            return true
        }

        return false
    }
    
    func textViewDidChangeSelection(_ textView: UITextView) {
        if self.view.window != nil {
            if textView.textColor == colorPlaceholder {
                textView.selectedTextRange = textView.textRange(from: textView.beginningOfDocument, to: textView.beginningOfDocument)
            }
        }
    }
    
    func textViewDidChange(_ textView: UITextView) {
        checkEnabledPublish()
        updateViewModelText(textView: textView)
    }
    
    
    func textViewDidEndEditing(_ textView: UITextView) {
        textView.text = textView.text.trimming()
    }
    
    func updateViewModelText(textView: UITextView) {
        updatedText(textView.text! == textPlaceholder ? "" : textView.text!, tag: textView.tag)
    }
}

//MARK: - DGPPickerView Delegate

extension AddEditEntryViewController: DGPPickerViewModel {
    var selectedIndex: Int {
        return router?.dataStore?.selectedIndex ?? -1
    }
    
    public func numberOfComponents() -> Int {
        return 1
    }
    
    public func numberOfItems() -> Int {
        return viewModel?.categories.count ?? 0
    }
    
    public func titleOfItem(with index: Int, component: Int) -> String {
        return viewModel?.categories[index].name ?? ""
    }
    
    public func didSelectItem(with index: Int, component: Int) -> Void {
        interactor?.setSelectedIndex(index)
        loadCategory()
    }
    
    public func finishDGPPickerView() {
        isSelectingCategory = false
    }
    
}

//MARK: - AddEditEntryViewController

extension AddEditEntryViewController: PasswordGeneratorDelegate {
    
    func passwordGenerator(didUpdatePassword password: String) {
        loadPassword(text: password)
    }
}


